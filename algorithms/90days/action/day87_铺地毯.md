# 铺地毯 _ 2021 网易校招

牛牛有一块 `2 * n` 的空白瓷砖，并且有 `1 * 2` 和 `2 * 3` 两种类型的地毯（地毯可以旋转）。现在他想满足以下条件：

- 瓷砖需要被铺满
- 地毯之间没有重叠
- 地毯不能铺出瓷砖外
求一共有多少种铺地毯的方案，由于结果可能很大，因此你需要返回结果取模 10007。

## 思路

仍然和爬楼梯类似，属于爬楼梯的扩展。

爬楼梯的基本思路是： 由于爬上第 n 级只能从第 n - 1 和 第 n - 2爬上去，因此 f(n) 就 等于 f(n - 1) + f(n - 2)。

而爬楼梯类似，我们:

- 假设 f(n - 1) 已经计算好了，那么我们可以用一种方法来铺到 f(n)。

[![img](https://camo.githubusercontent.com/cfc20b21b6fd46beb7f4f0c426fbb7c3b353af04/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316769333777726f7369346a3330397530356f6161652e6a7067)](https://camo.githubusercontent.com/cfc20b21b6fd46beb7f4f0c426fbb7c3b353af04/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316769333777726f7369346a3330397530356f6161652e6a7067)

- 假设 f(n - 2) 已经计算好了，那么我们可以用两种方法来铺到 f(n)。

[![image](https://user-images.githubusercontent.com/12479470/91162065-2c726e80-e6fe-11ea-9cc2-659b5be3855d.png)](https://user-images.githubusercontent.com/12479470/91162065-2c726e80-e6fe-11ea-9cc2-659b5be3855d.png)

- 假设 f(n - 3) 已经计算好了，那么我们可以用四方法来铺到 f(n)。

[![image](https://user-images.githubusercontent.com/12479470/91162483-b4587880-e6fe-11ea-9df0-178a7ba43c8b.png)](https://user-images.githubusercontent.com/12479470/91162483-b4587880-e6fe-11ea-9df0-178a7ba43c8b.png)

而实际上，虽然上面的分析过程是没有问题，但是这并不意味着转移方程就是 `f(n) = f(n - 1 ) + 2 * f(n - 2) + 4 * f(n -3)`。

因此我讲义里面提到了 DP 问题的核心在于定义状态，思考转移方程，在这里状态的定义比较简单。而状态转移方程的关键点是**不重不漏**，而上面的状态有明显的重复，重复部分我使用虚线标识出来了。 比如 f(n - 2) 的虚线部分，重复的其实就是 f(n - 1) 的一部分。 要想做到不重不漏，那么其实就是将我画的实现部分加起来就行了，因此状态转移方程就是 f(n) = f(n - 1 ) + f(n - 2) + f(n -3)。

由于第 n 个状态只依赖 n - 1，n - 2 和 n - 3， 因此 n - 3 之前是不需要报错的，因此可以用三个变量存储即可。这和爬楼梯类似，这个技巧叫做滚动数组优化。

```python
class Solution:
    def f(self, N: int) -> int:
        a, b = 1, 1
        for i in range(1, N):
            a, b = b, b + a
        return b % 10007
```

## 铺瓷砖（动态规划）

力扣上有个题目是
**[790. 多米诺和托米诺平铺](https://leetcode-cn.com/problems/domino-and-tromino-tiling/)**，
去看了很多的思路和解释，我觉得有两种思路可以去理解这种题目，或者说看到这种题目能够有思路并能正确的解决问题。

1. 1维DP，就是直接找递推公式的思路，其实这个递推公式其实就是高中学数列的时候的数列通项公式，有时候我们可以一下子看出来通项公式，而有的时候我们需要借助数学归纳法来证明，得到递推公式。当然也可以通过迭代递推。数学归纳法则是一种动态规划的思路，最主要的是找到状态转移方程，而递推法更像递归的思路，逐渐分割为子问题。

所以对于这种类型的简单题来说，完全可以根据经验或者简单的数学归纳甚至是找规律的方式，解决问题，而难题，类似于各大OJ，各大比赛出现过的题目，肯定不会出现在面试中咯。

1. 多维DP，看了题解区很多的思路，我发现这种多维的DP对于初学者很友好，从定义DP状态开始，到DP状态转移，最后得出结果的每一步都是有意义的，我觉得掌握这种方式的思路还是很有必要的，这对于解决其他的动态规划问题很有帮助。

当然，这种多维的DP最后优化后就是一维的，甚至是O(1)空间的，就是状态压缩，而多维的方式，是一种有固定思路，固定模式，易掌握，通用的解题思路，在下面的代码中还没有给出这样的思路，有时间再说吧。

### 题目描述

```text
有一块大小是 2 * n 的墙面，现在需要用不同规格的瓷砖铺满，瓷砖规格如下，请计算一共有多少种铺设的方法。
```

PS:由于结果可能很大：返回值需要对 10^9 + 7 取余。
由于Python自带大数，可以不用担心结果溢出，为了保持代码美观，只在return时取余。

### 类型1：A砖：2 * 1型

此处撰写解题思路

### 代码

```text
# 一维DP状态转移方程：dp[i] = dp[i - 1] + dp[i - 2]
class Solution:
    def numTilings(self, N: int) -> int:
        dp = [0] * (N + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, N + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[-1] % 1000000007


# 状态压缩：
# 只需要记录两个状态
class Solution:
    def numTilings(self, N: int) -> int:
        a, b = 1, 1
        for i in range(2, N + 1):
            a, b = b, b + a
        return b % 1000000007
```

### `类型2：A砖：2 * 1型、B砖：2 * 2型`

此处撰写解题思路

### 代码1

```text
# 一维DP状态转移方程：dp[i] = dp[i - 1] + 2 * dp[i - 2]
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        dp = [0] * (N + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, N + 1):
            dp[i] = dp[i - 1] + 2 * dp[i - 2]
        return dp[-1] % 1000000007


# 状态压缩：
# 只需要记录两个状态
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        a, b = 1, 1
        for i in range(2, N + 1):
            a, b = b, b + 2 * a
        return b % 1000000007
```

### 类型3：A砖：`2 * 1`型、B砖：`2 * 3`型

此处撰写解题思路

### 代码2

```text
# 一维DP状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        dp = [0] * (N + 1)
        dp[0], dp[1], dp[2] = 1, 1, 2
        for i in range(3, N + 1):
            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
        return dp[-1] % 1000000007


# 状态压缩：
# 只需要记录三个状态
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        a, b, c = 1, 1, 2
        for i in range(3, N + 1):
            a, b, c = b, c, c + b + a
        return c % 1000000007
```

### 类型4：A砖：2 * 1型、B砖：L型（三块小砖组成）

此处撰写解题思路

### 代码3

```text
# 790. 多米诺和托米诺平铺

# 一维DP状态转移方程：dp[i] = 2 * dp[i - 1] + dp[i - 3]
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        dp = [0] * (N + 1)
        dp[0], dp[1], dp[2] = 1, 1, 2
        for i in range(3, N + 1):
            dp[i] = 2 * dp[i - 1] + dp[i - 3]
        return dp[-1] % 1000000007


# 状态压缩：
# 只需要记录三个状态
class Solution:
    def numTilings(self, N: int) -> int:
        if N <= 1:
            return 1
        a, b, c = 1, 1, 2
        for i in range(3, N + 1):
            a, b, c = b, c, 2 * c + a
        return c % 1000000007
```

### 其他类型

- 墙面变化

```text
墙面：3 * n、A砖：1 * 1、B砖：2 * 2
方程：dp[i] = dp[i - 1] + 2 * dp[i - 2]
解释：dp[i]可以由两种方式得到，
当右边少一排时，可以全部铺A，这有一种方法，
当右边少两排时，可以铺一个B，两个A，这有两种方法，
所以递推式：dp[i] = dp[i - 1] + 2 * dp[i - 2]
来源：POJ - 2663
墙面：3 * n、A砖：1 * 2
方程：
n为偶数时：dp[i] = 4 * dp[i - 2] + dp[i - 4]
n为奇数时：0
来源：zju - acmclub - 1059
墙面：3 * n、A砖：1 * 3、B砖：2 * 3、C砖：3 * 3
方程：
dp[1] = 1、dp[2] = 2、dp[3] = 7
dp[i] = dp[i - 1] + dp[i - 2] + 4 * dp[i - 3] n >= 4
解释：
一般情况（n>4），记铺设3*n墙壁总方案数为dp(n).

1） 如果先铺3*1的墙壁，铺设3*1的方案数为1，还剩下3 *（n-1）的墙壁的总方案数位为dp(n-1)，故这种情况共有有1*dp(n-1)种方案。

2） 如果先铺3*2的墙壁，铺设3*2的方案数为1（因为要去掉与1）中重复的情况），还剩下3 *（n-2）的墙壁的总方案数为dp(n-2)，故这种情况共有有1 * dp(n-2)种方案。

3） 如果先铺3*3的墙壁，铺设3*3的方案数为4（去掉与（1），（2）重复的情况），还剩下3 *（n-3）的墙壁的总分数为dp(n-3)，故这种情况共有有4 * dp(n-3)种方案。

所以可以得出递推式dp(n)=dp(n-1)+dp(n-2)+dp*f(n-3);(n>=4)
```

- 可行性

```text
来源：未知，可能是某挑战程序设计竞赛
题目：用 1 * 2 的砖铺 m * n 的地面，地面上有一些障碍物，求是否可以不用切割砖块铺满地面，并计算时间复杂度。
思路：应该可以用dp，也可以用DFS搜索，估计和力扣上的 迷宫、寻宝、地下城 等问题相似，太难啦
```

- 最优性

### 题目：墙面：n * m，瓷砖：正方形瓷砖，目标：最少需要用到多少块方形瓷砖

[1240. 铺瓷砖](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares/)

### 代码4

```text
# 1240. 铺瓷砖
```
