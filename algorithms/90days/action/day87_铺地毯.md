# 铺地毯 _ 2021 网易校招

牛牛有一块 `2 * n` 的空白瓷砖，并且有 `1 * 2` 和 `2 * 3` 两种类型的地毯（地毯可以旋转）。现在他想满足以下条件：

- 瓷砖需要被铺满
- 地毯之间没有重叠
- 地毯不能铺出瓷砖外
求一共有多少种铺地毯的方案，由于结果可能很大，因此你需要返回结果取模 10007。

## 思路

仍然和爬楼梯类似，属于爬楼梯的扩展。

爬楼梯的基本思路是： 由于爬上第 n 级只能从第 n - 1 和 第 n - 2爬上去，因此 f(n) 就 等于 f(n - 1) + f(n - 2)。

而爬楼梯类似，我们:

- 假设 f(n - 1) 已经计算好了，那么我们可以用一种方法来铺到 f(n)。

[![img](https://camo.githubusercontent.com/cfc20b21b6fd46beb7f4f0c426fbb7c3b353af04/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316769333777726f7369346a3330397530356f6161652e6a7067)](https://camo.githubusercontent.com/cfc20b21b6fd46beb7f4f0c426fbb7c3b353af04/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303753385a496c6c79316769333777726f7369346a3330397530356f6161652e6a7067)

- 假设 f(n - 2) 已经计算好了，那么我们可以用两种方法来铺到 f(n)。

[![image](https://user-images.githubusercontent.com/12479470/91162065-2c726e80-e6fe-11ea-9cc2-659b5be3855d.png)](https://user-images.githubusercontent.com/12479470/91162065-2c726e80-e6fe-11ea-9cc2-659b5be3855d.png)

- 假设 f(n - 3) 已经计算好了，那么我们可以用四方法来铺到 f(n)。

[![image](https://user-images.githubusercontent.com/12479470/91162483-b4587880-e6fe-11ea-9df0-178a7ba43c8b.png)](https://user-images.githubusercontent.com/12479470/91162483-b4587880-e6fe-11ea-9df0-178a7ba43c8b.png)

而实际上，虽然上面的分析过程是没有问题，但是这并不意味着转移方程就是 `f(n) = f(n - 1 ) + 2 * f(n - 2) + 4 * f(n -3)`。

因此我讲义里面提到了 DP 问题的核心在于定义状态，思考转移方程，在这里状态的定义比较简单。而状态转移方程的关键点是**不重不漏**，而上面的状态有明显的重复，重复部分我使用虚线标识出来了。 比如 f(n - 2) 的虚线部分，重复的其实就是 f(n - 1) 的一部分。 要想做到不重不漏，那么其实就是将我画的实现部分加起来就行了，因此状态转移方程就是 f(n) = f(n - 1 ) + f(n - 2) + f(n -3)。

由于第 n 个状态只依赖 n - 1，n - 2 和 n - 3， 因此 n - 3 之前是不需要报错的，因此可以用三个变量存储即可。这和爬楼梯类似，这个技巧叫做滚动数组优化。

```python
class Solution:
    def f(self, N: int) -> int:
        a, b = 1, 1
        for i in range(1, N):
            a, b = b, b + a
        return b % 10007
```
